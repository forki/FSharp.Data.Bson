(* Copyright (c) 2013-2014 Tomas Petricek and Gustavo Guerra
 * Copyright (c) 2014 Max Hirschhorn
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *)

// -----------------------------------------------------------------------------
// BSON type provider - methods that are called from the generated erased code
// -----------------------------------------------------------------------------

namespace BsonProvider.Runtime

open System
open System.ComponentModel
open System.IO
open MongoDB.Bson
open MongoDB.Bson.Serialization
open FSharp.Data.Runtime.StructuralTypes

#nowarn "10001"

/// [omit]
type IBsonTop =
    abstract BsonValue : BsonValue

    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    abstract Path : unit -> string

    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    abstract Create : value:BsonValue * pathIncrement:string -> IBsonTop

/// Underlying representation of types generated by BsonProvider
[<StructuredFormatDisplay("{_Print}")>]
type BsonTop =
    private {
        /// [omit]
        Value : BsonValue
        /// [omit]
        Path : string
    }

    interface IBsonTop with
        member x.BsonValue = x.Value
        member x.Path() = x.Path
        member x.Create(value, pathIncrement) =
            BsonTop.Create(value, x.Path + pathIncrement)

    /// The underlying BsonValue
    member x.BsonValue = x.Value

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    member x._Print = x.Value.ToString()

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    override x.ToString() = x._Print

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member Create(value, path) =
        { Value = value
          Path = path } :> IBsonTop

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member ParseSeq(stream:Stream) =
        seq {
            use stream = stream
            while stream.Position <> stream.Length do
                yield BsonSerializer.Deserialize<BsonDocument>(stream)
        }

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member ParseArray(stream:Stream) =
        BsonTop.ParseSeq stream
        |> Seq.map (fun value -> BsonTop.Create(value, "$"))
        |> Seq.toArray

    /// [omit]
    [<EditorBrowsableAttribute(EditorBrowsableState.Never)>]
    [<CompilerMessageAttribute("This method is intended for use in generated code only.", 10001, IsHidden=true, IsError=false)>]
    static member ParseDocuments(docs:#seq<BsonDocument>) =
        docs
        |> Seq.map (fun value -> BsonTop.Create(value, "$"))
        |> Seq.toArray

[<AutoOpen>]
module ActivePatterns =

    let (|OptionalBsonType|_|) = function
    | BsonType.Null
    | BsonType.Undefined as bsonType -> Some bsonType
    | _ -> None

/// Static helper methods called from the generated code for working with BSON
type BsonRuntime =

    // -------------------------------------------------------------------------
    // bson option -> type
    // -------------------------------------------------------------------------

    static member ConvertBoolean = Option.bind BsonConversions.AsBoolean

    static member ConvertInteger = Option.bind BsonConversions.AsInteger

    static member ConvertInteger64 = Option.bind BsonConversions.AsInteger64

    static member ConvertFloat = Option.bind BsonConversions.AsFloat

    static member ConvertString = Option.bind BsonConversions.AsString

    static member ConvertDateTime = Option.bind BsonConversions.AsDateTime

    static member ConvertObjectId = Option.bind BsonConversions.AsObjectId

    /// Operation that extracts the value from an option and reports a
    /// meaningful error message if the value is not present.
    static member GetNonOptionalValue<'T>(top:IBsonTop,
                                          converted:option<'T>) =
        match converted with
        | Some x -> x
        | None -> failwithf "Expecting a %A at '%s' : %A"
                            typeof<'T> (top.Path()) top.BsonValue

    /// Convert BSON array to array of target types
    static member ConvertArray<'T>(top:IBsonTop, func:Func<IBsonTop,'T>) =
        match top.BsonValue.BsonType with
        | BsonType.Array ->
            top.BsonValue.AsBsonArray.Values
            |> Seq.mapi (fun i value -> top.Create(value, sprintf ".%d" i))
            |> Seq.map func.Invoke
            |> Seq.toArray

        | _ -> failwithf "Expecting a list at '%s' : %A"
                         (top.Path()) top.BsonValue

    static member ConvertArrayId(top) =
        BsonRuntime.ConvertArray<IBsonTop>(top, Func<_,_> id)

    /// Convert BSON array to array of target types
    static member ConvertArrayOfOptionals<'T>(top:IBsonTop,
                                              func:Func<IBsonTop,'T>) =
        match top.BsonValue.BsonType with
        | BsonType.Array ->
            top.BsonValue.AsBsonArray.Values
            |> Seq.map (fun value ->
                match value.BsonType with
                | OptionalBsonType _ -> None
                | _ -> Some value)
            |> Seq.mapi (fun i value ->
                let create value = top.Create(value, sprintf ".%d" i)
                Option.map create value)
            |> Seq.map (Option.map func.Invoke)
            |> Seq.toArray

        | _ -> failwithf "Expecting a list at '%s' : %A"
                         (top.Path()) top.BsonValue

    /// Optionally get property of BsonDocument
    static member TryGetPropertyUnpacked(top:IBsonTop, field) =
        match top.BsonValue.BsonType with
        | BsonType.Document ->
            let doc = top.BsonValue.AsBsonDocument
            if doc.Contains field then
                let value = doc.GetValue field
                match value.BsonType with
                | OptionalBsonType _ -> None
                | _ -> Some value
            else None
        | _ -> None

    /// Optionally get property wrapped in a BsonTop
    static member TryGetPropertyPacked(top:IBsonTop, field) =
        BsonRuntime.TryGetPropertyUnpacked(top, field)
        |> Option.map (fun value -> top.Create(value, sprintf ".%s" field))

    /// Get property wrapped in a BsonTop
    static member GetPropertyPacked(top:IBsonTop, field) =
        match BsonRuntime.TryGetPropertyPacked(top, field) with
        | Some top -> top
        | None -> failwithf "Property '%s' not found at '%s' : %A"
                            field (top.Path()) top.BsonValue

    /// Optionally get property and convert it to the specified type
    static member ConvertOptionalProperty<'T>(top:IBsonTop, field,
                                              func:Func<IBsonTop,'T>) =
        BsonRuntime.TryGetPropertyPacked(top, field)
        |> Option.map func.Invoke

    /// Converts an object to a BsonValue
    static member private ToBsonValue (value:obj) =
        let optionToBsonValue = function
        | Some v -> BsonRuntime.ToBsonValue v
        | None -> BsonNull.Value :> BsonValue

        match value with
        | null -> BsonNull.Value :> BsonValue

        // primitive types
        | :? bool      as v -> BsonBoolean  v :> BsonValue
        | :? int       as v -> BsonInt32    v :> BsonValue
        | :? int64     as v -> BsonInt64    v :> BsonValue
        | :? float     as v -> BsonDouble   v :> BsonValue
        | :? DateTime  as v -> BsonDateTime v :> BsonValue
        | :? string    as v -> BsonString   v :> BsonValue
        | :? BsonValue as v -> v
        | :? IBsonTop  as v -> v.BsonValue

        // option types
        | :? option<bool>      as v -> optionToBsonValue v
        | :? option<int>       as v -> optionToBsonValue v
        | :? option<int64>     as v -> optionToBsonValue v
        | :? option<float>     as v -> optionToBsonValue v
        | :? option<DateTime>  as v -> optionToBsonValue v
        | :? option<string>    as v -> optionToBsonValue v
        | :? option<BsonValue> as v -> optionToBsonValue v
        | :? option<IBsonTop>  as v -> optionToBsonValue v

        | :? Array as v ->
            let elems = [ for elem in v -> BsonRuntime.ToBsonValue elem ]
            BsonArray elems :> BsonValue

        | _ -> failwithf "Cannot create BsonValue from %A" value

    /// Creates a BsonDocument wrapped in a BsonTop
    static member CreateDocument properties =
        let value =
            properties
            |> Array.map (fun (k, v) ->
                BsonElement(k, BsonRuntime.ToBsonValue v))
        BsonTop.Create(BsonDocument(value :> seq<BsonElement>), "$")
